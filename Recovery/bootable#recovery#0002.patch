From 639dba76a4cb1e09da32b5d0d4179e0072acd3f6 Mon Sep 17 00:00:00 2001
From: Zhigang <zhigang.yu@amlogic.com>
Date: Tue, 23 Oct 2018 14:51:56 +0800
Subject: [PATCH] recovery: add recovery.kl parse for key map[1/1]

PD# SWPL-620

add function for parse /etc/recovery.kl.

Change-Id: Ib6f42686ab94a2c2e0edd2485383171a0708b88d
---
 ui.cpp | 121 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 ui.h   |  34 +++++++++++++++++-
 2 files changed, 153 insertions(+), 2 deletions(-)

diff --git a/ui.cpp b/ui.cpp
index 3c9ded7..d15819c 100644
--- a/ui.cpp
+++ b/ui.cpp
@@ -53,6 +53,12 @@ static constexpr const char* BRIGHTNESS_FILE_SDM =
 static constexpr const char* MAX_BRIGHTNESS_FILE_SDM =
     "/sys/class/backlight/panel0-backlight/max_brightness";
 
+static RecoveryUI::KeyMapItem_t g_presupposed_keymap[] = {
+    { "select", Device::kInvokeItem, {BTN_MOUSE, BTN_LEFT, -1, -1, -1, -1} }
+};
+
+#define NUM_PRESUPPOSED_KEY_MAP (sizeof(g_presupposed_keymap) / sizeof(g_presupposed_keymap[0]))
+
 RecoveryUI::RecoveryUI()
     : brightness_normal_(50),
       brightness_dimmed_(25),
@@ -78,6 +84,7 @@ RecoveryUI::RecoveryUI()
   pthread_mutex_init(&key_queue_mutex, nullptr);
   pthread_cond_init(&key_queue_cond, nullptr);
   memset(key_pressed, 0, sizeof(key_pressed));
+  load_key_map();
 }
 
 void RecoveryUI::OnKeyDetected(int key_code) {
@@ -319,7 +326,12 @@ int RecoveryUI::OnInputEvent(int fd, uint32_t epevents) {
       }
     }
 
-    ProcessKey(ev.code, ev.value);
+    int code = getMapKey(ev.code);
+    if (code > 0) {
+        ProcessKey(code, ev.value);
+    } else {
+        ProcessKey(ev.code, ev.value);
+    }
   }
 
   return 0;
@@ -408,6 +420,113 @@ void RecoveryUI::time_key(int key_code, int count) {
   if (long_press) KeyLongPress(key_code);
 }
 
+void RecoveryUI::load_key_map() {
+    FILE* fstab = fopen("/etc/recovery.kl", "r");
+    if (fstab != NULL) {
+        printf("loaded /etc/recovery.kl\n");
+        int alloc = 2;
+        keys_map = (KeyMapItem_t*)malloc(alloc * sizeof(KeyMapItem_t));
+
+        keys_map[0].type = "down";
+        keys_map[0].value = KEY_DOWN;
+        keys_map[0].key[0] = -1;
+        keys_map[0].key[1] = -1;
+        keys_map[0].key[2] = -1;
+        keys_map[0].key[3] = -1;
+        keys_map[0].key[4] = -1;
+        keys_map[0].key[5] = -1;
+        num_keys = 0;
+
+        char buffer[1024];
+        int i;
+        int value = -1;
+        while (fgets(buffer, sizeof(buffer)-1, fstab)) {
+            for (i = 0; buffer[i] && isspace(buffer[i]); ++i);
+
+            if (buffer[i] == '\0' || buffer[i] == '#') continue;
+
+            char* original = strdup(buffer);
+
+            char* type = strtok(original+i, " \t\n");
+            char* key1 = strtok(NULL, " \t\n");
+            char* key2 = strtok(NULL, " \t\n");
+            char* key3 = strtok(NULL, " \t\n");
+            char* key4 = strtok(NULL, " \t\n");
+            char* key5 = strtok(NULL, " \t\n");
+            char* key6 = strtok(NULL, " \t\n");
+
+            value = getKey(type);
+            if (type && key1 && (value > 0)) {
+                while (num_keys >= alloc) {
+                    alloc *= 2;
+                    keys_map = (KeyMapItem_t*)realloc(keys_map, alloc*sizeof(KeyMapItem_t));
+                }
+                keys_map[num_keys].type = strdup(type);
+                keys_map[num_keys].value = value;
+                keys_map[num_keys].key[0] = key1?atoi(key1):-1;
+                keys_map[num_keys].key[1] = key2?atoi(key2):-1;
+                keys_map[num_keys].key[2] = key3?atoi(key3):-1;
+                keys_map[num_keys].key[3] = key4?atoi(key4):-1;
+                keys_map[num_keys].key[4] = key5?atoi(key5):-1;
+                keys_map[num_keys].key[5] = key6?atoi(key6):-1;
+
+                ++num_keys;
+            } else {
+                printf("skipping malformed recovery.lk line: %s\n", original);
+            }
+            free(original);
+        }
+
+        fclose(fstab);
+    } else {
+        printf("failed to open /etc/recovery.kl, use default map\n");
+        num_keys = NUM_DEFAULT_KEY_MAP;
+        keys_map = g_default_keymap;
+    }
+
+    printf("recovery key map table:\n");
+    int i;
+    for (i = 0; i < num_keys; ++i) {
+        KeyMapItem_t* v = &keys_map[i];
+        printf("  %d type:%s value:%d key:%d %d %d %d %d %d\n", i, v->type, v->value,
+              v->key[0], v->key[1], v->key[2], v->key[3], v->key[4], v->key[5]);
+    }
+    printf("\n");
+}
+
+int RecoveryUI::getKey(char *key) {
+    if (key == NULL) return -1;
+
+    unsigned int i;
+    for (i = 0; i < NUM_CTRLINFO; i++) {
+        CtrlInfo_t *info = &g_ctrlinfo[i];
+        if (strcmp(info->type, key) == 0) {
+            return info->value;
+        }
+    }
+    return -1;
+}
+
+int RecoveryUI::getMapKey(int key) {
+    int i,j;
+    for (i = 0; i < num_keys; i++) {
+        KeyMapItem_t* v = &keys_map[i];
+        for (j = 0; j < 6; j++) {
+            if (v->key[j] == key)
+                return v->value;
+        }
+    }
+
+    for (i = 0; i < (int)NUM_PRESUPPOSED_KEY_MAP; i++) {
+        for (j = 0; j < 6; j++) {
+            if (g_presupposed_keymap[i].key[j] == key)
+                return g_presupposed_keymap[i].value;
+        }
+    }
+
+    return -1;
+}
+
 void RecoveryUI::EnqueueKey(int key_code) {
   pthread_mutex_lock(&key_queue_mutex);
   const int queue_max = sizeof(key_queue) / sizeof(key_queue[0]);
diff --git a/ui.h b/ui.h
index 4c54d69..4123399 100644
--- a/ui.h
+++ b/ui.h
@@ -47,6 +47,12 @@ class RecoveryUI {
     IGNORE
   };
 
+    struct KeyMapItem_t {
+        const char* type;
+        int value;
+        int key[6];
+    };
+
   RecoveryUI();
 
   virtual ~RecoveryUI() {}
@@ -168,6 +174,30 @@ class RecoveryUI {
     int count;
   };
 
+  int num_keys;
+  KeyMapItem_t* keys_map;
+
+  KeyMapItem_t g_default_keymap[3] = {
+      { "select", KEY_ENTER, {KEY_ENTER, KEY_TAB, KEY_BACK, -1, -1, -1} },
+      { "down", KEY_DOWN, {KEY_DOWN, KEY_VOLUMEDOWN, KEY_PAGEDOWN, -1, -1, -1} },
+      { "up", KEY_UP, {KEY_UP, KEY_VOLUMEUP, KEY_PAGEUP, -1, -1, -1} },
+  };
+
+  #define NUM_DEFAULT_KEY_MAP 3
+
+  struct CtrlInfo_t {
+      const char *type;
+      int value;
+  };
+
+  CtrlInfo_t g_ctrlinfo[3] = {
+      { "select", KEY_ENTER },
+      { "down", KEY_DOWN },
+      { "up", KEY_UP },
+  };
+
+  #define NUM_CTRLINFO 3
+
   // The sensitivity when detecting a swipe.
   const int kTouchLowThreshold;
   const int kTouchHighThreshold;
@@ -181,7 +211,9 @@ class RecoveryUI {
 
   static void* time_key_helper(void* cookie);
   void time_key(int key_code, int count);
-
+  int getKey(char *key);
+  void load_key_map();
+  int getMapKey(int key);
   bool InitScreensaver();
 
   // Key event input queue
-- 
1.9.1

