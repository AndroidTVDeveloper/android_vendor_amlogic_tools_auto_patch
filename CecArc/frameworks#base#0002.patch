From 0c73ebd8bed72fa35298d9e989eab2f3808335e4 Mon Sep 17 00:00:00 2001
From: Jinping Wang <jinping.wang@amlogic.com>
Date: Sat, 3 Nov 2018 17:50:05 +0800
Subject: [PATCH] cec: merge to 1 patch [1/1]

PD# SWPL-887

Problem:
too much cec patch

Solution:
merge to 1 patch

Verify:
verify by p321

Change-Id: I9b05ef7b81d14a0a17382c14f350de110358b95b
Signed-off-by: Jinping Wang <jinping.wang@amlogic.com>
---
 .../com/android/server/audio/AudioService.java     |  2 +-
 .../android/server/hdmi/HdmiCecLocalDevice.java    | 21 ++++-
 .../server/hdmi/HdmiCecLocalDevicePlayback.java    | 94 +++++++++++++++++++++-
 .../android/server/hdmi/HdmiCecLocalDeviceTv.java  | 17 +++-
 .../android/server/hdmi/HdmiCecMessageBuilder.java | 11 +++
 .../android/server/hdmi/HdmiControlService.java    |  8 +-
 .../android/server/hdmi/RoutingControlAction.java  |  7 +-
 7 files changed, 150 insertions(+), 10 deletions(-)
 mode change 100755 => 100644 services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java

diff --git a/services/core/java/com/android/server/audio/AudioService.java b/services/core/java/com/android/server/audio/AudioService.java
index 13de652..7972422 100644
--- a/services/core/java/com/android/server/audio/AudioService.java
+++ b/services/core/java/com/android/server/audio/AudioService.java
@@ -7392,7 +7392,7 @@ public class AudioService extends IAudioService.Stub
                 return false;
             }
             boolean suppress = false;
-            if (resolvedStream == DEFAULT_VOL_STREAM_NO_PLAYBACK && mController != null) {
+            if (resolvedStream == AudioSystem.STREAM_RING && mController != null) {
                 final long now = SystemClock.uptimeMillis();
                 if ((flags & AudioManager.FLAG_SHOW_UI) != 0 && !mVisible) {
                     // ui will become visible
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
old mode 100755
new mode 100644
index 0cba76b..ab41f10
--- a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
@@ -45,6 +45,9 @@ abstract class HdmiCecLocalDevice {
 
     private static final int MSG_DISABLE_DEVICE_TIMEOUT = 1;
     private static final int MSG_USER_CONTROL_RELEASE_TIMEOUT = 2;
+    protected static final int MSG_SELECT_PORT_FLAGS = 3;
+    protected static final int MSG_GET_MENU_LANGUAGE_TIMEOUT = 4;
+
     // Timeout in millisecond for device clean up (5s).
     // Normal actions timeout is 2s but some of them would have several sequence of timeout.
     private static final int DEVICE_CLEANUP_TIMEOUT = 5000;
@@ -59,6 +62,10 @@ abstract class HdmiCecLocalDevice {
     protected HdmiDeviceInfo mDeviceInfo;
     protected int mLastKeycode = HdmiCecKeycode.UNSUPPORTED_KEYCODE;
     protected int mLastKeyRepeatCount = 0;
+    protected static final int DELAY_TIMEOUT_MS = 5000;
+    protected static int mSelectedPortId = -1;
+    protected static boolean mFilterOtpEnabled = false;
+    protected static final int GET_MSG_TIMEOUT = 15000;
 
     static class ActiveSource {
         int logicalAddress;
@@ -129,7 +136,7 @@ abstract class HdmiCecLocalDevice {
     // Note that access to this collection should happen in service thread.
     private final ArrayList<HdmiCecFeatureAction> mActions = new ArrayList<>();
 
-    private final Handler mHandler = new Handler () {
+    protected final Handler mHandler = new Handler () {
         @Override
         public void handleMessage(Message msg) {
             switch (msg.what) {
@@ -139,6 +146,13 @@ abstract class HdmiCecLocalDevice {
                 case MSG_USER_CONTROL_RELEASE_TIMEOUT:
                     handleUserControlReleased();
                     break;
+                case MSG_SELECT_PORT_FLAGS:
+                    mFilterOtpEnabled = false;
+                    Slog.d(TAG, "reset mFilterOtpEnabled to false");
+                    break;
+                case MSG_GET_MENU_LANGUAGE_TIMEOUT:
+                    sendGetMenuLanguageCommand(Constants.ADDR_TV);
+                    break;
             }
         }
     };
@@ -580,6 +594,10 @@ abstract class HdmiCecLocalDevice {
         // Do nothing.
     }
 
+    protected void sendGetMenuLanguageCommand(int dest) {
+        // Do nothing.
+    }
+
     protected boolean handleSetOsdName(HdmiCecMessage message) {
         // The default behavior of <Set Osd Name> is doing nothing.
         return true;
@@ -899,6 +917,7 @@ abstract class HdmiCecLocalDevice {
     @ServiceThreadOnly
     protected void sendKeyEvent(int keyCode, boolean isPressed) {
         assertRunOnServiceThread();
+        HdmiLogger.debug("sendKeyEvent keyCode:  " + keyCode);
         if (!HdmiCecKeycode.isSupportedKeycode(keyCode)) {
             Slog.w(TAG, "Unsupported key: " + keyCode);
             return;
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java
index d45b00b..98cc380 100644
--- a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java
@@ -36,6 +36,8 @@ import java.util.List;
 import java.util.Locale;
 
 import java.util.List;
+import android.os.Handler;
+import android.os.Message;
 
 /**
  * Represent a logical device of type Playback residing in Android system.
@@ -47,7 +49,7 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
             SystemProperties.getBoolean(Constants.PROPERTY_WAKE_ON_HOTPLUG, true);
 
     private static final boolean SET_MENU_LANGUAGE =
-            SystemProperties.getBoolean(Constants.PROPERTY_SET_MENU_LANGUAGE, false);
+            SystemProperties.getBoolean(Constants.PROPERTY_SET_MENU_LANGUAGE, true);
 
     private boolean mIsActiveSource = false;
 
@@ -80,6 +82,8 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
                 mAddress, mService.getPhysicalAddress(), mDeviceType));
         mService.sendCecCommand(HdmiCecMessageBuilder.buildDeviceVendorIdCommand(
                 mAddress, mService.getVendorId()));
+        mHandler.sendMessageDelayed(
+                Message.obtain(mHandler, MSG_GET_MENU_LANGUAGE_TIMEOUT), GET_MSG_TIMEOUT);
         startQueuedActions();
     }
 
@@ -159,6 +163,11 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         if (!connected) {
             getWakeLock().release();
         }
+        if (connected) {
+            mHandler.removeMessages(MSG_GET_MENU_LANGUAGE_TIMEOUT);
+            mHandler.sendMessageDelayed(
+                    Message.obtain(mHandler, MSG_GET_MENU_LANGUAGE_TIMEOUT), GET_MSG_TIMEOUT/2);
+        }
     }
 
     @Override
@@ -269,6 +278,9 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         assertRunOnServiceThread();
         int newPath = HdmiUtils.twoBytesToInt(message.getParams(), 2);
         maySetActiveSource(newPath);
+        if (newPath == mService.getPhysicalAddress()) {
+            maySendActiveSource(message.getSource());
+        }
         return true;  // Broadcast message.
     }
 
@@ -320,9 +332,19 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         if (!SET_MENU_LANGUAGE) {
             return false;
         }
-
         try {
             String iso3Language = new String(message.getParams(), 0, 3, "US-ASCII");
+            HdmiLogger.debug("handleSetMenuLanguage, iso3Language: " + iso3Language);
+            if (iso3Language.equals("chi") || iso3Language.equals("zho")) {
+                HdmiCecLanguageHelp cecLanguage = new HdmiCecLanguageHelp(iso3Language);
+                Locale locale = new Locale(cecLanguage.LanguageCode(), cecLanguage.CountryCode());
+                try {
+                    LocalePicker.updateLocale(locale);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+                return true;
+            }
             Locale currentLocale = mService.getContext().getResources().getConfiguration().locale;
             if (currentLocale.getISO3Language().equals(iso3Language)) {
                 // Do not switch language if the new language is the same as the current one.
@@ -354,6 +376,14 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         }
     }
 
+    protected void sendGetMenuLanguageCommand(int dest) {
+        if (!SET_MENU_LANGUAGE) {
+            return;
+        }
+        int targetAddress = Constants.ADDR_TV;
+        mService.sendCecCommand(HdmiCecMessageBuilder.buildGetMenuLanguage(mAddress, targetAddress));
+    }
+
     @Override
     protected int findKeyReceiverAddress() {
         return Constants.ADDR_TV;
@@ -390,6 +420,66 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         pw.println("mAutoTvOff:" + mAutoTvOff);
     }
 
+    class HdmiCecLanguageHelp {
+        private final String [][] mCecLanguage = {
+            {"chi", "zh", "CN"},
+            {"zho", "zh", "TW"}
+        };
+
+        private int mIndex;
+
+        HdmiCecLanguageHelp(String str) {
+            int size;
+            for (size = 0; size < mCecLanguage.length; size++) {
+                if (mCecLanguage[size][0].equals(str)) {
+                    mIndex = size;
+                    break;
+                }
+            }
+            if (size == mCecLanguage.length) {
+                mIndex = -1;
+            }
+        }
+
+        public String LanguageCode() {
+            if (mIndex != -1) {
+                return mCecLanguage[mIndex][1];
+            }
+            return null;
+        }
+
+        public String CountryCode() {
+            if (mIndex != -1) {
+                return mCecLanguage[mIndex][2];
+            }
+            return null;
+        }
+
+        /*
+         * get android language code for cec language code
+         */
+        public final String getCecLanguageCode(String cecLanguage) {
+            int size;
+            for (size = 0; size < mCecLanguage.length; size++) {
+                if (mCecLanguage[size][0].equals(cecLanguage))
+                    return mCecLanguage[size][1];
+            }
+            return null;
+        }
+
+        /*
+         * get android country code for cec language code
+         */
+        public final String getCecCountryCode(String cecLanguage) {
+            int size;
+            for (size = 0; size < mCecLanguage.length; size++) {
+                if (mCecLanguage[size][0].equals(cecLanguage))
+                    return mCecLanguage[size][2];
+            }
+            return null;
+        }
+    }
+
     // Wrapper interface over PowerManager.WakeLock
     private interface ActiveWakeLock {
         void acquire();
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java b/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
index de0f298..0a45be7 100644
--- a/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
@@ -300,7 +300,8 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
             return;
         }
         removeAction(DeviceSelectAction.class);
-        addAndStartAction(new DeviceSelectAction(this, targetDevice, callback));
+        invokeCallback(callback, HdmiControlManager.RESULT_SUCCESS);
+        addAndStartAction(new DeviceSelectAction(this, targetDevice, null));
     }
 
     @ServiceThreadOnly
@@ -394,6 +395,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     void doManualPortSwitching(int portId, IHdmiControlCallback callback) {
         assertRunOnServiceThread();
         // Seq #20
+        HdmiLogger.debug("doManualPortSwitching portId: " + portId);
         if (!mService.isValidPortId(portId)) {
             invokeCallback(callback, HdmiControlManager.RESULT_INCORRECT_MODE);
             return;
@@ -417,6 +419,12 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         }
         int newPath = mService.portIdToPath(portId);
         startRoutingControl(oldPath, newPath, true, callback);
+        if (mSelectedPortId != -1 && mSelectedPortId != portId) {
+            mFilterOtpEnabled = true;
+            mHandler.removeMessages(MSG_SELECT_PORT_FLAGS);
+            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_SELECT_PORT_FLAGS, 0, 0), DELAY_TIMEOUT_MS);
+        }
+        mSelectedPortId = portId;
     }
 
     @ServiceThreadOnly
@@ -426,12 +434,13 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         if (oldPath == newPath) {
             return;
         }
+        invokeCallback(callback, HdmiControlManager.RESULT_SUCCESS);
         HdmiCecMessage routingChange =
                 HdmiCecMessageBuilder.buildRoutingChange(mAddress, oldPath, newPath);
         mService.sendCecCommand(routingChange);
         removeAction(RoutingControlAction.class);
         addAndStartAction(
-                new RoutingControlAction(this, newPath, queryDevicePowerStatus, callback));
+                new RoutingControlAction(this, newPath, queryDevicePowerStatus, null));
     }
 
     @ServiceThreadOnly
@@ -468,6 +477,10 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     protected boolean handleActiveSource(HdmiCecMessage message) {
         assertRunOnServiceThread();
         int logicalAddress = message.getSource();
+        if (mFilterOtpEnabled) {
+            Slog.d(TAG,"filter Active Source Msg, logicalAddress: " + logicalAddress);
+            return true;
+        }
         int physicalAddress = HdmiUtils.twoBytesToInt(message.getParams());
         HdmiDeviceInfo info = getCecDeviceInfo(logicalAddress);
         if (info == null) {
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java b/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java
index 9a51e3c..06ee301 100644
--- a/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java
@@ -440,6 +440,17 @@ public class HdmiCecMessageBuilder {
     }
 
     /**
+     * Build &lt;GetMenuLanguage&gt; command.
+     *
+     * @param src source address of command
+     * @param dest destination address of command
+     * @return newly created {@link HdmiCecMessage}
+     */
+    public static HdmiCecMessage buildGetMenuLanguage(int src, int dest) {
+        return buildCommand(src, dest, Constants.MESSAGE_GET_MENU_LANGUAGE);
+    }
+
+    /**
      * Build &lt;Vendor Command&gt; command.
      *
      * @param src source address of command
diff --git a/services/core/java/com/android/server/hdmi/HdmiControlService.java b/services/core/java/com/android/server/hdmi/HdmiControlService.java
index b06dba9..af61986 100644
--- a/services/core/java/com/android/server/hdmi/HdmiControlService.java
+++ b/services/core/java/com/android/server/hdmi/HdmiControlService.java
@@ -392,6 +392,13 @@ public final class HdmiControlService extends SystemService {
         mCecController = HdmiCecController.create(this);
         if (mCecController != null) {
             if (mHdmiControlEnabled) {
+                mHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        initializeCec(INITIATED_BY_BOOT_UP);
+                        initPortInfo();
+                    }
+                });
                 initializeCec(INITIATED_BY_BOOT_UP);
             }
         } else {
@@ -405,7 +412,6 @@ public final class HdmiControlService extends SystemService {
         }
         mMhlDevices = Collections.emptyList();
 
-        initPortInfo();
         mMessageValidator = new HdmiCecMessageValidator(this);
         publishBinderService(Context.HDMI_CONTROL_SERVICE, new BinderService());
 
diff --git a/services/core/java/com/android/server/hdmi/RoutingControlAction.java b/services/core/java/com/android/server/hdmi/RoutingControlAction.java
index 6c8694e..0dc853b 100644
--- a/services/core/java/com/android/server/hdmi/RoutingControlAction.java
+++ b/services/core/java/com/android/server/hdmi/RoutingControlAction.java
@@ -88,6 +88,8 @@ final class RoutingControlAction extends HdmiCecFeatureAction {
     public boolean start() {
         mState = STATE_WAIT_FOR_ROUTING_INFORMATION;
         addTimer(mState, TIMEOUT_ROUTING_INFORMATION_MS);
+        tv().setPrevPortId(tv().getActivePortId());
+        tv().setActivePath(mCurrentRoutingPath);
         return true;
     }
 
@@ -105,6 +107,7 @@ final class RoutingControlAction extends HdmiCecFeatureAction {
                 return true;
             }
             mCurrentRoutingPath = routingPath;
+            tv().setActivePath(mCurrentRoutingPath);
             // Stop possible previous routing change sequence if in progress.
             removeActionExcept(RoutingControlAction.class, this);
             addTimer(mState, TIMEOUT_ROUTING_INFORMATION_MS);
@@ -128,9 +131,7 @@ final class RoutingControlAction extends HdmiCecFeatureAction {
     }
 
     private void updateActiveInput() {
-        HdmiCecLocalDeviceTv tv = tv();
-        tv.setPrevPortId(tv.getActivePortId());
-        tv.updateActiveInput(mCurrentRoutingPath, mNotifyInputChange);
+        tv().updateActiveInput(mCurrentRoutingPath, mNotifyInputChange);
     }
 
     private int getTvPowerStatus() {
-- 
2.10.2

