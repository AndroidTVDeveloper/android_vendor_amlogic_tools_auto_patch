From 48d4a687cb06fbd8f66815867bb33e5a8bad4a39 Mon Sep 17 00:00:00 2001
From: Jinping Wang <jinping.wang@amlogic.com>
Date: Mon, 12 Nov 2018 15:12:45 +0800
Subject: [PATCH] cec: wakeup when routing change [1/1]

PD# SWPL-1147

Problem:
lack wakeup when routing change

Solution:
wakeup when routing change

Verify:
verify by p321

Change-Id: Ibd43993879950e9b45ada3a6e048482423437167
Signed-off-by: Jinping Wang <jinping.wang@amlogic.com>
---
 .../com/android/server/audio/AudioService.java     |  2 +-
 .../android/server/hdmi/HdmiCecLocalDevice.java    | 21 ++++-
 .../server/hdmi/HdmiCecLocalDevicePlayback.java    | 94 +++++++++++++++++++++-
 .../android/server/hdmi/HdmiCecLocalDeviceTv.java  | 12 +++
 .../android/server/hdmi/HdmiCecMessageBuilder.java | 11 +++
 .../android/server/hdmi/HdmiControlService.java    | 15 +++-
 .../android/server/hdmi/RoutingControlAction.java  | 30 ++++++-
 7 files changed, 174 insertions(+), 11 deletions(-)
 mode change 100755 => 100644 services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java

diff --git a/services/core/java/com/android/server/audio/AudioService.java b/services/core/java/com/android/server/audio/AudioService.java
index 989b989..6f2b214 100644
--- a/services/core/java/com/android/server/audio/AudioService.java
+++ b/services/core/java/com/android/server/audio/AudioService.java
@@ -7422,7 +7422,7 @@ public class AudioService extends IAudioService.Stub
                 return false;
             }
             boolean suppress = false;
-            if (resolvedStream == DEFAULT_VOL_STREAM_NO_PLAYBACK && mController != null) {
+            if (resolvedStream == AudioSystem.STREAM_RING && mController != null) {
                 final long now = SystemClock.uptimeMillis();
                 if ((flags & AudioManager.FLAG_SHOW_UI) != 0 && !mVisible) {
                     // ui will become visible
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
old mode 100755
new mode 100644
index fbaafca..ffba380
--- a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
@@ -45,6 +45,9 @@ abstract class HdmiCecLocalDevice {
 
     private static final int MSG_DISABLE_DEVICE_TIMEOUT = 1;
     private static final int MSG_USER_CONTROL_RELEASE_TIMEOUT = 2;
+    protected static final int MSG_SELECT_PORT_FLAGS = 3;
+    protected static final int MSG_GET_MENU_LANGUAGE_TIMEOUT = 4;
+
     // Timeout in millisecond for device clean up (5s).
     // Normal actions timeout is 2s but some of them would have several sequence of timeout.
     private static final int DEVICE_CLEANUP_TIMEOUT = 5000;
@@ -59,6 +62,10 @@ abstract class HdmiCecLocalDevice {
     protected HdmiDeviceInfo mDeviceInfo;
     protected int mLastKeycode = HdmiCecKeycode.UNSUPPORTED_KEYCODE;
     protected int mLastKeyRepeatCount = 0;
+    protected static final int DELAY_TIMEOUT_MS = 5000;
+    protected static int mSelectedPortId = -1;
+    protected static boolean mFilterOtpEnabled = false;
+    protected static final int GET_MSG_TIMEOUT = 15000;
 
     static class ActiveSource {
         int logicalAddress;
@@ -129,7 +136,7 @@ abstract class HdmiCecLocalDevice {
     // Note that access to this collection should happen in service thread.
     private final ArrayList<HdmiCecFeatureAction> mActions = new ArrayList<>();
 
-    private final Handler mHandler = new Handler () {
+    protected final Handler mHandler = new Handler () {
         @Override
         public void handleMessage(Message msg) {
             switch (msg.what) {
@@ -139,6 +146,13 @@ abstract class HdmiCecLocalDevice {
                 case MSG_USER_CONTROL_RELEASE_TIMEOUT:
                     handleUserControlReleased();
                     break;
+                case MSG_SELECT_PORT_FLAGS:
+                    mFilterOtpEnabled = false;
+                    Slog.d(TAG, "reset mFilterOtpEnabled to false");
+                    break;
+                case MSG_GET_MENU_LANGUAGE_TIMEOUT:
+                    sendGetMenuLanguageCommand(Constants.ADDR_TV);
+                    break;
             }
         }
     };
@@ -582,6 +596,10 @@ abstract class HdmiCecLocalDevice {
         // Do nothing.
     }
 
+    protected void sendGetMenuLanguageCommand(int dest) {
+        // Do nothing.
+    }
+
     protected boolean handleSetOsdName(HdmiCecMessage message) {
         // The default behavior of <Set Osd Name> is doing nothing.
         return true;
@@ -901,6 +919,7 @@ abstract class HdmiCecLocalDevice {
     @ServiceThreadOnly
     protected void sendKeyEvent(int keyCode, boolean isPressed) {
         assertRunOnServiceThread();
+        HdmiLogger.debug("sendKeyEvent keyCode:  " + keyCode);
         if (!HdmiCecKeycode.isSupportedKeycode(keyCode)) {
             Slog.w(TAG, "Unsupported key: " + keyCode);
             return;
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java
index d45b00b..af3feb9 100644
--- a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevicePlayback.java
@@ -36,6 +36,8 @@ import java.util.List;
 import java.util.Locale;
 
 import java.util.List;
+import android.os.Handler;
+import android.os.Message;
 
 /**
  * Represent a logical device of type Playback residing in Android system.
@@ -47,7 +49,7 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
             SystemProperties.getBoolean(Constants.PROPERTY_WAKE_ON_HOTPLUG, true);
 
     private static final boolean SET_MENU_LANGUAGE =
-            SystemProperties.getBoolean(Constants.PROPERTY_SET_MENU_LANGUAGE, false);
+            SystemProperties.getBoolean(Constants.PROPERTY_SET_MENU_LANGUAGE, true);
 
     private boolean mIsActiveSource = false;
 
@@ -80,6 +82,8 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
                 mAddress, mService.getPhysicalAddress(), mDeviceType));
         mService.sendCecCommand(HdmiCecMessageBuilder.buildDeviceVendorIdCommand(
                 mAddress, mService.getVendorId()));
+        mHandler.sendMessageDelayed(
+                Message.obtain(mHandler, MSG_GET_MENU_LANGUAGE_TIMEOUT), GET_MSG_TIMEOUT);
         startQueuedActions();
     }
 
@@ -159,6 +163,11 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         if (!connected) {
             getWakeLock().release();
         }
+        if (connected) {
+            mHandler.removeMessages(MSG_GET_MENU_LANGUAGE_TIMEOUT);
+            mHandler.sendMessageDelayed(
+                    Message.obtain(mHandler, MSG_GET_MENU_LANGUAGE_TIMEOUT), GET_MSG_TIMEOUT/2);
+        }
     }
 
     @Override
@@ -269,6 +278,9 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         assertRunOnServiceThread();
         int newPath = HdmiUtils.twoBytesToInt(message.getParams(), 2);
         maySetActiveSource(newPath);
+        if (newPath == mService.getPhysicalAddress()) {
+            maySendActiveSource(message.getSource());
+        }
         return true;  // Broadcast message.
     }
 
@@ -320,9 +332,19 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         if (!SET_MENU_LANGUAGE) {
             return false;
         }
-
         try {
             String iso3Language = new String(message.getParams(), 0, 3, "US-ASCII");
+            HdmiLogger.debug("handleSetMenuLanguage, iso3Language: " + iso3Language);
+            if (iso3Language.equals("chi") || iso3Language.equals("zho")) {
+                HdmiCecLanguageHelp cecLanguage = new HdmiCecLanguageHelp(iso3Language);
+                Locale locale = new Locale(cecLanguage.LanguageCode(), cecLanguage.CountryCode());
+                try {
+                    LocalePicker.updateLocale(locale);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+                return true;
+            }
             Locale currentLocale = mService.getContext().getResources().getConfiguration().locale;
             if (currentLocale.getISO3Language().equals(iso3Language)) {
                 // Do not switch language if the new language is the same as the current one.
@@ -354,6 +376,14 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         }
     }
 
+    protected void sendGetMenuLanguageCommand(int dest) {
+        if (!SET_MENU_LANGUAGE) {
+            return;
+        }
+        int targetAddress = Constants.ADDR_TV;
+        mService.sendCecCommand(HdmiCecMessageBuilder.buildGetMenuLanguage(mAddress, targetAddress));
+    }
+
     @Override
     protected int findKeyReceiverAddress() {
         return Constants.ADDR_TV;
@@ -390,6 +420,66 @@ final class HdmiCecLocalDevicePlayback extends HdmiCecLocalDevice {
         pw.println("mAutoTvOff:" + mAutoTvOff);
     }
 
+    class HdmiCecLanguageHelp {
+        private final String [][] mCecLanguage = {
+            {"chi", "zh", "TW"},
+            {"zho", "zh", "CN"}
+        };
+
+        private int mIndex;
+
+        HdmiCecLanguageHelp(String str) {
+            int size;
+            for (size = 0; size < mCecLanguage.length; size++) {
+                if (mCecLanguage[size][0].equals(str)) {
+                    mIndex = size;
+                    break;
+                }
+            }
+            if (size == mCecLanguage.length) {
+                mIndex = -1;
+            }
+        }
+
+        public String LanguageCode() {
+            if (mIndex != -1) {
+                return mCecLanguage[mIndex][1];
+            }
+            return null;
+        }
+
+        public String CountryCode() {
+            if (mIndex != -1) {
+                return mCecLanguage[mIndex][2];
+            }
+            return null;
+        }
+
+        /*
+         * get android language code for cec language code
+         */
+        public final String getCecLanguageCode(String cecLanguage) {
+            int size;
+            for (size = 0; size < mCecLanguage.length; size++) {
+                if (mCecLanguage[size][0].equals(cecLanguage))
+                    return mCecLanguage[size][1];
+            }
+            return null;
+        }
+
+        /*
+         * get android country code for cec language code
+         */
+        public final String getCecCountryCode(String cecLanguage) {
+            int size;
+            for (size = 0; size < mCecLanguage.length; size++) {
+                if (mCecLanguage[size][0].equals(cecLanguage))
+                    return mCecLanguage[size][2];
+            }
+            return null;
+        }
+    }
+
     // Wrapper interface over PowerManager.WakeLock
     private interface ActiveWakeLock {
         void acquire();
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java b/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
index 4031d19..389ff34 100644
--- a/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecLocalDeviceTv.java
@@ -273,6 +273,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     @ServiceThreadOnly
     void deviceSelect(int id, IHdmiControlCallback callback) {
         assertRunOnServiceThread();
+        HdmiLogger.debug("deviceSelect deviceId: " + id);
         HdmiDeviceInfo targetDevice = mDeviceInfos.get(id);
         if (targetDevice == null) {
             invokeCallback(callback, HdmiControlManager.RESULT_TARGET_NOT_AVAILABLE);
@@ -394,6 +395,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     void doManualPortSwitching(int portId, IHdmiControlCallback callback) {
         assertRunOnServiceThread();
         // Seq #20
+        HdmiLogger.debug("doManualPortSwitching portId: " + portId);
         if (!mService.isValidPortId(portId)) {
             invokeCallback(callback, HdmiControlManager.RESULT_INCORRECT_MODE);
             return;
@@ -417,6 +419,12 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
         }
         int newPath = mService.portIdToPath(portId);
         startRoutingControl(oldPath, newPath, true, callback);
+        if (mSelectedPortId != -1 && mSelectedPortId != portId) {
+            mFilterOtpEnabled = true;
+            mHandler.removeMessages(MSG_SELECT_PORT_FLAGS);
+            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_SELECT_PORT_FLAGS, 0, 0), DELAY_TIMEOUT_MS);
+        }
+        mSelectedPortId = portId;
     }
 
     @ServiceThreadOnly
@@ -468,6 +476,10 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     protected boolean handleActiveSource(HdmiCecMessage message) {
         assertRunOnServiceThread();
         int logicalAddress = message.getSource();
+        if (mFilterOtpEnabled) {
+            Slog.d(TAG,"filter Active Source Msg, logicalAddress: " + logicalAddress);
+            return true;
+        }
         int physicalAddress = HdmiUtils.twoBytesToInt(message.getParams());
         HdmiDeviceInfo info = getCecDeviceInfo(logicalAddress);
         if (info == null) {
diff --git a/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java b/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java
index 9a51e3c..06ee301 100644
--- a/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecMessageBuilder.java
@@ -440,6 +440,17 @@ public class HdmiCecMessageBuilder {
     }
 
     /**
+     * Build &lt;GetMenuLanguage&gt; command.
+     *
+     * @param src source address of command
+     * @param dest destination address of command
+     * @return newly created {@link HdmiCecMessage}
+     */
+    public static HdmiCecMessage buildGetMenuLanguage(int src, int dest) {
+        return buildCommand(src, dest, Constants.MESSAGE_GET_MENU_LANGUAGE);
+    }
+
+    /**
      * Build &lt;Vendor Command&gt; command.
      *
      * @param src source address of command
diff --git a/services/core/java/com/android/server/hdmi/HdmiControlService.java b/services/core/java/com/android/server/hdmi/HdmiControlService.java
index dd8b7eb..12f08b7 100644
--- a/services/core/java/com/android/server/hdmi/HdmiControlService.java
+++ b/services/core/java/com/android/server/hdmi/HdmiControlService.java
@@ -1321,7 +1321,7 @@ public final class HdmiControlService extends SystemService {
         @Override
         public void sendKeyEvent(final int deviceType, final int keyCode, final boolean isPressed) {
             enforceAccessPermission();
-            runOnServiceThread(new Runnable() {
+            runOnServiceThreadAtFrontOfQueue(new Runnable() {
                 @Override
                 public void run() {
                     HdmiMhlLocalDeviceStub device = mMhlController.getLocalDevice(mActivePortId);
@@ -2050,6 +2050,10 @@ public final class HdmiControlService extends SystemService {
         return mWakeUpMessageReceived;
     }
 
+    boolean isStandbyMessageReceived() {
+        return mStandbyMessageReceived;
+    }
+
     @ServiceThreadOnly
     private void onWakeUp() {
         assertRunOnServiceThread();
@@ -2074,12 +2078,17 @@ public final class HdmiControlService extends SystemService {
         mPowerStatus = HdmiControlManager.POWER_STATUS_TRANSIENT_TO_STANDBY;
         invokeVendorCommandListenersOnControlStateChanged(false,
                 HdmiControlManager.CONTROL_STATE_CHANGED_REASON_STANDBY);
-        if (!canGoToStandby()) {
+
+        final List<HdmiCecLocalDevice> devices = getAllLocalDevices();
+
+        if ((STANDBY_SHUTDOWN == standbyAction) ||(!isStandbyMessageReceived() && !canGoToStandby())) {
             mPowerStatus = HdmiControlManager.POWER_STATUS_STANDBY;
+            for (HdmiCecLocalDevice device : devices) {
+                device.onStandby(mStandbyMessageReceived, standbyAction);
+            }
             return;
         }
 
-        final List<HdmiCecLocalDevice> devices = getAllLocalDevices();
         disableDevices(new PendingActionClearedCallback() {
             @Override
             public void onCleared(HdmiCecLocalDevice device) {
diff --git a/services/core/java/com/android/server/hdmi/RoutingControlAction.java b/services/core/java/com/android/server/hdmi/RoutingControlAction.java
index 6c8694e..6c56609 100644
--- a/services/core/java/com/android/server/hdmi/RoutingControlAction.java
+++ b/services/core/java/com/android/server/hdmi/RoutingControlAction.java
@@ -66,7 +66,7 @@ final class RoutingControlAction extends HdmiCecFeatureAction {
     // <Inactive Source> command.
     private final boolean mNotifyInputChange;
 
-    @Nullable private final IHdmiControlCallback mCallback;
+    @Nullable private IHdmiControlCallback mCallback;
 
     // The latest routing path. Updated by each <Routing Information> from CEC switches.
     private int mCurrentRoutingPath;
@@ -88,6 +88,10 @@ final class RoutingControlAction extends HdmiCecFeatureAction {
     public boolean start() {
         mState = STATE_WAIT_FOR_ROUTING_INFORMATION;
         addTimer(mState, TIMEOUT_ROUTING_INFORMATION_MS);
+        tv().setPrevPortId(tv().getActivePortId());
+        tv().setActivePath(mCurrentRoutingPath);
+        finishWithCallback(HdmiControlManager.RESULT_SUCCESS);
+        mCallback = null;
         return true;
     }
 
@@ -105,6 +109,7 @@ final class RoutingControlAction extends HdmiCecFeatureAction {
                 return true;
             }
             mCurrentRoutingPath = routingPath;
+            tv().setActivePath(mCurrentRoutingPath);
             // Stop possible previous routing change sequence if in progress.
             removeActionExcept(RoutingControlAction.class, this);
             addTimer(mState, TIMEOUT_ROUTING_INFORMATION_MS);
@@ -123,14 +128,26 @@ final class RoutingControlAction extends HdmiCecFeatureAction {
             if (isPowerOnOrTransient(devicePowerStatus)) {
                 sendSetStreamPath();
             }
+            if (isPowerOffOrTransient(devicePowerStatus)) {
+                turnOnDevice();
+            }
         }
         finishWithCallback(HdmiControlManager.RESULT_SUCCESS);
     }
 
+    private void turnOnDevice() {
+        HdmiDeviceInfo device = tv().getDeviceInfoByPath(mCurrentRoutingPath);
+        if (device != null) {
+            int deviceLogicalAddress = device.getLogicalAddress();
+            sendUserControlPressedAndReleased(deviceLogicalAddress,
+                    HdmiCecKeycode.CEC_KEYCODE_POWER);
+            sendUserControlPressedAndReleased(deviceLogicalAddress,
+                    HdmiCecKeycode.CEC_KEYCODE_POWER_ON_FUNCTION);
+        }
+    }
+
     private void updateActiveInput() {
-        HdmiCecLocalDeviceTv tv = tv();
-        tv.setPrevPortId(tv.getActivePortId());
-        tv.updateActiveInput(mCurrentRoutingPath, mNotifyInputChange);
+        tv().updateActiveInput(mCurrentRoutingPath, mNotifyInputChange);
     }
 
     private int getTvPowerStatus() {
@@ -142,6 +159,11 @@ final class RoutingControlAction extends HdmiCecFeatureAction {
                 || status == HdmiControlManager.POWER_STATUS_TRANSIENT_TO_ON;
     }
 
+    private static boolean isPowerOffOrTransient(int status) {
+        return status == HdmiControlManager.POWER_STATUS_STANDBY
+                || status == HdmiControlManager.POWER_STATUS_TRANSIENT_TO_STANDBY;
+    }
+
     private void sendSetStreamPath() {
         sendCommand(HdmiCecMessageBuilder.buildSetStreamPath(getSourceAddress(),
                 mCurrentRoutingPath));
-- 
1.9.1

